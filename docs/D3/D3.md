### **Step 3: Enhancing Attendance Features, Developing Leave Management, Reporting Mechanism, and Implementing Bonus Features**

Congratulations on successfully completing the **Authentication & Core Features Development** phase! Now, we'll proceed to enhance your application by implementing the following functionalities:

1. **Enhancing Attendance Features**
   - Automatic deductions from annual leave based on lateness.
   - Notifications for Authorized Users when employees are late or have low leave balances.

2. **Developing Leave Management**
   - Allow employees to view and request leaves.
   - Enable Authorized Users to approve or reject leave requests.

3. **Reporting Mechanism**
   - Generate monthly reports summarizing employee working hours.

4. **Implement Additional (Bonus) Features**
   - Set up Celery for asynchronous tasks like sending notifications.
   - Containerize the application using Docker.
   - Integrate Swagger for API documentation.

We'll tackle each of these sequentially. Let's dive in!

---

## **3.1. Enhancing Attendance Features**

### **3.1.1. Automatic Deductions from Annual Leave Based on Lateness**

**Objective:**
Automatically deduct from an employeeâ€™s annual leave balance based on the duration they are late.

**Approach:**
- Define a policy for deductions, e.g., for every **30 minutes** late, deduct **0.25 days** from the annual leave.
- Update the `AttendanceRecord` model to reflect deductions.
- Implement the deduction logic in the `attendance_check_in` view.

**Implementation Steps:**

1. **Define Deduction Policy:**

   Let's assume:
   - **Deduction Rate:** For every **30 minutes** of lateness, deduct **0.25 days**.

2. **Update `AttendanceRecord` Model (Optional):**

   If you wish to track deductions separately, you can add a new field. However, it's manageable without this.

   ```python
   # backend/employees/models.py

   from django.conf import settings
   from django.db import models

   class AttendanceRecord(models.Model):
       employee = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='attendance_records')
       date = models.DateField()
       first_check_in = models.TimeField(null=True, blank=True)
       last_check_out = models.TimeField(null=True, blank=True)
       is_late = models.BooleanField(default=False)
       lateness_duration = models.DurationField(null=True, blank=True)
       leave_deducted = models.DecimalField(max_digits=5, decimal_places=2, default=0.00)  # New Field

       def __str__(self):
           return f"{self.employee.username} - {self.date}"
   ```

   **Note:** After adding a new field, don't forget to make and apply migrations.

   ```bash
   python manage.py makemigrations employees
   python manage.py migrate
   ```

3. **Implement Deduction Logic in `attendance_check_in` View:**

   Update the `attendance_check_in` view to calculate and deduct leave based on lateness.

   ```python
   # backend/employees/views.py

   from django.utils import timezone
   from django.contrib.auth.decorators import login_required, user_passes_test
   from django.contrib import messages
   from django.shortcuts import render, redirect
   from .forms import CheckInForm, CheckOutForm
   from .models import AttendanceRecord, EmployeeProfile
   from datetime import datetime, time, timedelta

   def is_personnel(user):
       return user.is_authenticated and not user.is_authorized

   def is_authorized_user(user):
       return user.is_authenticated and user.is_authorized

   @login_required(login_url='personnel_login')
   @user_passes_test(is_personnel)
   def attendance_check_in(request):
       user = request.user
       today = timezone.now().date()
       now_time = timezone.now().time()

       attendance, created = AttendanceRecord.objects.get_or_create(employee=user, date=today)

       if attendance.first_check_in:
           messages.info(request, "You have already checked in today.")
           return redirect('personnel_dashboard')

       if request.method == 'POST':
           form = CheckInForm(request.POST)
           if form.is_valid():
               check_in_time = form.cleaned_data.get('check_in_time') or now_time
               attendance.first_check_in = check_in_time

               # Determine if late
               company_start_time = time(8, 0)  # 08:00 AM
               if check_in_time > company_start_time:
                   attendance.is_late = True
                   # Calculate lateness_duration
                   check_in_datetime = datetime.combine(today, check_in_time)
                   company_start_datetime = datetime.combine(today, company_start_time)
                   lateness = check_in_datetime - company_start_datetime
                   attendance.lateness_duration = lateness

                   # Calculate leave deduction
                   lateness_minutes = lateness.seconds // 60
                   deduction_rate = 0.25  # 0.25 days per 30 minutes
                   deduction = (lateness_minutes / 30) * deduction_rate
                   deduction = round(deduction, 2)

                   # Update leave balance
                   profile = user.profile  # Assuming OneToOneField from User to EmployeeProfile
                   if profile.annual_leave_balance >= deduction:
                       profile.annual_leave_balance -= deduction
                       profile.save()
                       attendance.leave_deducted = deduction
                   else:
                       # Handle insufficient leave balance
                       messages.error(request, "Insufficient leave balance for deduction due to lateness.")
                       attendance.is_late = False
                       attendance.lateness_duration = None
                       deduction = 0
                   messages.info(request, f"Late by {lateness_minutes} minutes. Deducted {deduction} days from your annual leave.")
               else:
                   attendance.is_late = False
                   attendance.lateness_duration = None

               attendance.save()
               # Create notification if late
               if attendance.is_late:
                   notify_authorized_users_late(user, today, lateness, deduction)

               return redirect('personnel_dashboard')
       else:
           form = CheckInForm()

       context = {
           'form': form
       }
       return render(request, 'employees/attendance_check_in.html', context)

   def notify_authorized_users_late(employee, date, lateness, deduction):
       # Get all authorized users
       authorized_users = User.objects.filter(is_authorized=True)
       message = f"Employee {employee.username} was late on {date} by {lateness.seconds // 60} minutes and {deduction} days were deducted from their leave."
       for user in authorized_users:
           Notification.objects.create(recipient=user, message=message)
   ```

   **Explanation:**
   - **Deduction Calculation:**
     - Lateness duration is converted to minutes.
     - Deduct `0.25` days for every `30` minutes late.
   - **Leave Balance Update:**
     - Check if the employee has sufficient leave balance before deduction.
     - If insufficient, reset lateness status and notify the employee.
   - **Notification Creation:**
     - Notify all Authorized Users about the lateness and leave deduction.

4. **Ensure `employees.models.EmployeeProfile` Exists and is Correct:**

   Ensure the `EmployeeProfile` model is correctly set up to manage `annual_leave_balance`.

   ```python
   # backend/employees/models.py

   class EmployeeProfile(models.Model):
       user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='profile')
       full_name = models.CharField(max_length=255)
       department = models.CharField(max_length=100)
       position = models.CharField(max_length=100)
       annual_leave_balance = models.DecimalField(max_digits=5, decimal_places=2, default=15.00)

       def __str__(self):
           return self.full_name
   ```

   **Note:** Ensure that `annual_leave_balance` uses `DecimalField` for precision in financial or similar calculations.

5. **Run Migrations:**

   After modifying models, make and apply migrations.

   ```bash
   python manage.py makemigrations employees
   python manage.py migrate
   ```

### **3.1.2. Develop Notifications for Authorized Users**

**Objective:**
Notify Authorized Users when employees are late or have low leave balances.

**Approach:**
- Utilize the existing `Notification` model.
- Create notifications upon certain triggers (lateness, low leave).
- Display notifications in the Authorized Users' dashboard.

**Implementation Steps:**

1. **Ensure Notification Model is Properly Defined:**

   ```python
   # backend/employees/models.py

   class Notification(models.Model):
       recipient = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='notifications')
       message = models.TextField()
       is_read = models.BooleanField(default=False)
       timestamp = models.DateTimeField(auto_now_add=True)

       def __str__(self):
           return f"Notification to {self.recipient.username} at {self.timestamp}"
   ```

2. **Create Helper Functions to Generate Notifications:**

   Update `views.py` to include notification creation when leave balance is low.

   ```python
   # backend/employees/views.py

   def notify_authorized_users_low_leave(user):
       # Check if leave balance is below 3 days
       if user.profile.annual_leave_balance < 3:
           authorized_users = User.objects.filter(is_authorized=True)
           message = f"Employee {user.username} now has {user.profile.annual_leave_balance} days of annual leave remaining."
           for auth_user in authorized_users:
               Notification.objects.create(recipient=auth_user, message=message)
   ```

3. **Call Notification Function After Leave Deduction:**

   Update the `attendance_check_in` view to invoke `notify_authorized_users_low_leave` after deduction.

   ```python
   # backend/employees/views.py

   # ... existing code ...

               if profile.annual_leave_balance >= deduction:
                   profile.annual_leave_balance -= deduction
                   profile.save()
                   attendance.leave_deducted = deduction
                   # Check for low leave balance
                   if profile.annual_leave_balance < 3:
                       notify_authorized_users_low_leave(user)
               else:
                   # ... existing code ...
   ```

4. **Display Notifications in Authorized Users' Dashboard:**

   Update the `authorized_dashboard` view and template to show unread notifications.

   ```python
   # backend/employees/views.py

   @login_required(login_url='authorized_login')
   @user_passes_test(is_authorized_user)
   def authorized_dashboard(request):
       notifications = request.user.notifications.filter(is_read=False).order_by('-timestamp')
       # Optionally, mark notifications as read when viewed
       notifications.update(is_read=True)
       return render(request, 'employees/authorized_dashboard.html', {'notifications': notifications})
   ```

   ```html
   <!-- backend/employees/templates/employees/authorized_dashboard.html -->

   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <title>Authorized User Dashboard</title>
       <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
   </head>
   <body>
       <div class="container mt-5">
           <h1>Welcome, {{ request.user.username }} (Authorized User)</h1>
           <a href="{% url 'authorized_logout' %}" class="btn btn-danger">Logout</a>

           <!-- Notification Section -->
           {% if notifications %}
               <div class="alert alert-info mt-4">
                   <h4>Recent Notifications:</h4>
                   <ul>
                       {% for notification in notifications %}
                           <li>{{ notification.message }} - <small>{{ notification.timestamp }}</small></li>
                       {% endfor %}
                   </ul>
               </div>
           {% endif %}

           <!-- Other Dashboard Functionalities -->
           <p><a href="{% url 'view_attendance_records' %}" class="btn btn-primary">View Attendance Records</a></p>
       </div>
   </body>
   </html>
   ```

5. **Run Migrations and Test:**

   Ensure that all models are migrated and test the notification functionality.

   ```bash
   python manage.py makemigrations employees
   python manage.py migrate
   ```

   **Testing:**
   - Create a Personnel user and perform a Check-In that results in a deduction.
   - Verify that Authorized Users receive appropriate notifications on their dashboard.
   - Ensure notifications are marked as read upon viewing.

---

## **3.2. Developing Leave Management**

### **3.2.1. Allow Employees to View and Request Leaves**

**Objective:**
Empower employees to view their current leave balance and request new leaves.

**Approach:**
- Create views and templates for viewing leave balance and submitting leave requests.
- Utilize the existing `LeaveRequest` model to handle requests.

**Implementation Steps:**

1. **Create View for Viewing Leave Balance and Used Leaves:**

   ```python
   # backend/employees/views.py

   @login_required(login_url='personnel_login')
   @user_passes_test(is_personnel)
   def view_leave_balance(request):
       user = request.user
       profile = user.profile
       total_leave = profile.annual_leave_balance
       # Calculate used leave
       used_leave = LeaveRequest.objects.filter(employee=user, status='A').aggregate(total=models.Sum('days')).get('total') or 0
       context = {
           'total_leave': total_leave,
           'used_leave': used_leave
       }
       return render(request, 'employees/view_leave_balance.html', context)
   ```

   **Note:**
   - `days` field should be part of the `LeaveRequest` model to represent the number of days requested.

2. **Update `LeaveRequest` Model to Include `days` Field:**

   ```python
   # backend/employees/models.py

   class LeaveRequest(models.Model):
       STATUS_CHOICES = [
           ('P', 'Pending'),
           ('A', 'Approved'),
           ('R', 'Rejected'),
       ]

       employee = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='leave_requests')
       start_date = models.DateField()
       end_date = models.DateField()
       reason = models.TextField()
       status = models.CharField(max_length=1, choices=STATUS_CHOICES, default='P')
       requested_at = models.DateTimeField(auto_now_add=True)
       responded_at = models.DateTimeField(null=True, blank=True)
       days = models.DecimalField(max_digits=5, decimal_places=2, default=0.00)  # New Field

       def __str__(self):
           return f"{self.employee.username} - {self.get_status_display()} from {self.start_date} to {self.end_date}"
       
       def save(self, *args, **kwargs):
           # Calculate number of days upon saving
           self.days = (self.end_date - self.start_date).days + 1
           super().save(*args, **kwargs)
   ```

   **Note:**
   - The `days` field represents the total number of days for the leave request.
   - The `save` method automatically calculates the number of days based on `start_date` and `end_date`.

3. **Make and Apply Migrations:**

   ```bash
   python manage.py makemigrations employees
   python manage.py migrate
   ```

4. **Create View for Submitting Leave Requests:**

   ```python
   # backend/employees/views.py

   from .forms import LeaveRequestForm

   @login_required(login_url='personnel_login')
   @user_passes_test(is_personnel)
   def request_leave(request):
       user = request.user
       profile = user.profile
       if request.method == 'POST':
           form = LeaveRequestForm(request.POST)
           if form.is_valid():
               leave_request = form.save(commit=False)
               leave_request.employee = user
               # Calculate number of days
               leave_request.days = (leave_request.end_date - leave_request.start_date).days + 1
               # Check if sufficient leave balance
               if profile.annual_leave_balance >= leave_request.days:
                   profile.annual_leave_balance -= leave_request.days
                   profile.save()
                   leave_request.save()
                   # Notify Authorized Users
                   notify_authorized_users_leave_request(leave_request)
                   messages.success(request, "Leave request submitted successfully.")
                   return redirect('view_leave_balance')
               else:
                   messages.error(request, "Insufficient leave balance for the requested period.")
       else:
           form = LeaveRequestForm()
       context = {
           'form': form
       }
       return render(request, 'employees/request_leave.html', context)
   ```

5. **Create `LeaveRequestForm`:**

   ```python
   # backend/employees/forms.py

   from django import forms
   from .models import LeaveRequest

   class LeaveRequestForm(forms.ModelForm):
       class Meta:
           model = LeaveRequest
           fields = ['start_date', 'end_date', 'reason']
           widgets = {
               'start_date': forms.DateInput(attrs={'type': 'date'}),
               'end_date': forms.DateInput(attrs={'type': 'date'}),
               'reason': forms.Textarea(attrs={'rows': 3}),
           }

       def clean(self):
           cleaned_data = super().clean()
           start_date = cleaned_data.get('start_date')
           end_date = cleaned_data.get('end_date')

           if start_date and end_date:
               if start_date > end_date:
                   raise forms.ValidationError("End date must be after start date.")
   ```

   **Explanation:**
   - The form validates that `end_date` is not before `start_date`.

6. **Create Helper Function to Notify Authorized Users About Leave Requests:**

   ```python
   # backend/employees/views.py

   def notify_authorized_users_leave_request(leave_request):
       authorized_users = User.objects.filter(is_authorized=True)
       message = f"Employee {leave_request.employee.username} has requested leave from {leave_request.start_date} to {leave_request.end_date} ({leave_request.days} days). Reason: {leave_request.reason}"
       for user in authorized_users:
           Notification.objects.create(recipient=user, message=message)
   ```

7. **Create Templates for Viewing Leave Balance and Requesting Leave:**

   - **`view_leave_balance.html`:**

     ```html
     <!-- backend/employees/templates/employees/view_leave_balance.html -->

     <!DOCTYPE html>
     <html lang="en">
     <head>
         <meta charset="UTF-8">
         <title>Leave Balance</title>
         <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
     </head>
     <body>
         <div class="container mt-5">
             <h2>Your Leave Balance</h2>
             <p><strong>Total Leave:</strong> {{ total_leave }} days</p>
             <p><strong>Used Leave:</strong> {{ used_leave }} days</p>
             <p><strong>Remaining Leave:</strong> {{ total_leave|add:"-{{ used_leave }}" }} days</p>
             <a href="{% url 'request_leave' %}" class="btn btn-primary">Request Leave</a>
             <a href="{% url 'personnel_dashboard' %}" class="btn btn-secondary">Back to Dashboard</a>
         </div>
     </body>
     </html>
     ```

   - **`request_leave.html`:**

     ```html
     <!-- backend/employees/templates/employees/request_leave.html -->

     <!DOCTYPE html>
     <html lang="en">
     <head>
         <meta charset="UTF-8">
         <title>Request Leave</title>
         <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
     </head>
     <body>
         <div class="container mt-5">
             <h2>Request Leave</h2>
             {% if messages %}
                 <div class="alert alert-danger">
                     {% for message in messages %}
                         <p>{{ message }}</p>
                     {% endfor %}
                 </div>
             {% endif %}
             <form method="POST">
                 {% csrf_token %}
                 {{ form.as_p }}
                 <button type="submit" class="btn btn-success">Submit Request</button>
             </form>
             <a href="{% url 'view_leave_balance' %}" class="btn btn-secondary mt-3">Back</a>
         </div>
     </body>
     </html>
     ```

8. **Update `employees/urls.py` with Leave Management URLs:**

   ```python
   # backend/employees/urls.py

   from django.urls import path
   from . import views
   from django.contrib.auth import views as auth_views

   urlpatterns = [
       # Authentication URLs
       path('login/personnel/', views.personnel_login, name='personnel_login'),
       path('logout/personnel/', auth_views.LogoutView.as_view(next_page='personnel_login'), name='personnel_logout'),

       path('login/authorized/', views.authorized_login, name='authorized_login'),
       path('logout/authorized/', auth_views.LogoutView.as_view(next_page='authorized_login'), name='authorized_logout'),

       # Dashboard URLs
       path('dashboard/personnel/', views.personnel_dashboard, name='personnel_dashboard'),
       path('dashboard/authorized/', views.authorized_dashboard, name='authorized_dashboard'),

       # Attendance URLs
       path('attendance/check-in/', views.attendance_check_in, name='attendance_check_in'),
       path('attendance/check-out/', views.attendance_check_out, name='attendance_check_out'),

       # Leave Management URLs
       path('leave/balance/', views.view_leave_balance, name='view_leave_balance'),
       path('leave/request/', views.request_leave, name='request_leave'),
   ]
   ```

9. **Create Necessary View for Authorized Users to Approve or Reject Leave Requests:**

   ```python
   # backend/employees/views.py

   from django.shortcuts import get_object_or_404

   @login_required(login_url='authorized_login')
   @user_passes_test(is_authorized_user)
   def approve_leave(request, leave_id):
       leave_request = get_object_or_404(LeaveRequest, id=leave_id, status='P')
       if request.method == 'POST':
           action = request.POST.get('action')
           if action == 'approve':
               leave_request.status = 'A'
               messages.success(request, "Leave request approved.")
           elif action == 'reject':
               # Refund the leave days if rejected
               profile = leave_request.employee.profile
               profile.annual_leave_balance += leave_request.days
               profile.save()
               leave_request.status = 'R'
               messages.success(request, "Leave request rejected.")
           leave_request.responded_at = timezone.now()
           leave_request.save()

           # Notify the employee about the decision
           notify_employee_leave_decision(leave_request)

           return redirect('view_pending_leave_requests')
       return render(request, 'employees/approve_leave.html', {'leave_request': leave_request})

   @login_required(login_url='authorized_login')
   @user_passes_test(is_authorized_user)
   def view_pending_leave_requests(request):
       pending_requests = LeaveRequest.objects.filter(status='P').order_by('-requested_at')
       context = {
           'pending_requests': pending_requests
       }
       return render(request, 'employees/view_pending_leave_requests.html', context)

   def notify_employee_leave_decision(leave_request):
       employee = leave_request.employee
       if leave_request.status == 'A':
           message = f"Your leave request from {leave_request.start_date} to {leave_request.end_date} has been approved."
       elif leave_request.status == 'R':
           message = f"Your leave request from {leave_request.start_date} to {leave_request.end_date} has been rejected."
       Notification.objects.create(recipient=employee, message=message)
   ```

10. **Create Necessary Forms for Leave Approval (Optional):**

    Since the approval process is simple (approve or reject via POST), omitting custom forms is acceptable. We're handling it via simple POST data.

11. **Create Templates for Leave Management:**

    - **`view_leave_balance.html`:** Created earlier.

    - **`request_leave.html`:** Created earlier.

    - **`view_pending_leave_requests.html`:**

      ```html
      <!-- backend/employees/templates/employees/view_pending_leave_requests.html -->

      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <title>Pending Leave Requests</title>
          <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
      </head>
      <body>
          <div class="container mt-5">
              <h2>Pending Leave Requests</h2>
              <a href="{% url 'authorized_dashboard' %}" class="btn btn-secondary mb-3">Back to Dashboard</a>
              {% if pending_requests %}
                  <table class="table table-bordered">
                      <thead>
                          <tr>
                              <th>Employee</th>
                              <th>Start Date</th>
                              <th>End Date</th>
                              <th>Days</th>
                              <th>Reason</th>
                              <th>Actions</th>
                          </tr>
                      </thead>
                      <tbody>
                          {% for request in pending_requests %}
                              <tr>
                                  <td>{{ request.employee.username }}</td>
                                  <td>{{ request.start_date }}</td>
                                  <td>{{ request.end_date }}</td>
                                  <td>{{ request.days }}</td>
                                  <td>{{ request.reason }}</td>
                                  <td>
                                      <a href="{% url 'approve_leave' request.id %}" class="btn btn-primary btn-sm">Review</a>
                                  </td>
                              </tr>
                          {% endfor %}
                      </tbody>
                  </table>
              {% else %}
                  <p>No pending leave requests.</p>
              {% endif %}
          </div>
      </body>
      </html>
      ```

    - **`approve_leave.html`:**

      ```html
      <!-- backend/employees/templates/employees/approve_leave.html -->

      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <title>Review Leave Request</title>
          <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
      </head>
      <body>
          <div class="container mt-5">
              <h2>Review Leave Request</h2>
              <p><strong>Employee:</strong> {{ leave_request.employee.username }}</p>
              <p><strong>Start Date:</strong> {{ leave_request.start_date }}</p>
              <p><strong>End Date:</strong> {{ leave_request.end_date }}</p>
              <p><strong>Days:</strong> {{ leave_request.days }}</p>
              <p><strong>Reason:</strong> {{ leave_request.reason }}</p>

              <form method="POST">
                  {% csrf_token %}
                  <button type="submit" name="action" value="approve" class="btn btn-success">Approve</button>
                  <button type="submit" name="action" value="reject" class="btn btn-danger">Reject</button>
              </form>

              <a href="{% url 'view_pending_leave_requests' %}" class="btn btn-secondary mt-3">Back to Pending Requests</a>
          </div>
      </body>
      </html>
      ```

12. **Update `employees/urls.py` with Leave Management URLs:**

    ```python
    # backend/employees/urls.py

    from django.urls import path
    from . import views
    from django.contrib.auth import views as auth_views

    urlpatterns = [
        # Authentication URLs
        path('login/personnel/', views.personnel_login, name='personnel_login'),
        path('logout/personnel/', auth_views.LogoutView.as_view(next_page='personnel_login'), name='personnel_logout'),

        path('login/authorized/', views.authorized_login, name='authorized_login'),
        path('logout/authorized/', auth_views.LogoutView.as_view(next_page='authorized_login'), name='authorized_logout'),

        # Dashboard URLs
        path('dashboard/personnel/', views.personnel_dashboard, name='personnel_dashboard'),
        path('dashboard/authorized/', views.authorized_dashboard, name='authorized_dashboard'),

        # Attendance URLs
        path('attendance/check-in/', views.attendance_check_in, name='attendance_check_in'),
        path('attendance/check-out/', views.attendance_check_out, name='attendance_check_out'),

        # Leave Management URLs
        path('leave/balance/', views.view_leave_balance, name='view_leave_balance'),
        path('leave/request/', views.request_leave, name='request_leave'),
        path('leave/pending/', views.view_pending_leave_requests, name='view_pending_leave_requests'),
        path('leave/approve/<int:leave_id>/', views.approve_leave, name='approve_leave'),
    ]
    ```

13. **Ensure All Necessary Forms and Models Are in Place:**

    - `LeaveRequest` model updated with `days` field.
    - `LeaveRequestForm` defined in `forms.py`.
    - Proper signals if needed.

14. **Run Migrations and Test:**

    ```bash
    python manage.py makemigrations employees
    python manage.py migrate
    ```

    **Testing:**
    - Create a Personnel user.
    - View leave balance.
    - Submit a leave request.
    - Log in as an Authorized User and approve/reject the request.
    - Verify leave balance updates and notification creation.

---

## **3.3. Reporting Mechanism**

### **3.3.1. Generate Monthly Reports Summarizing Employee Working Hours**

**Objective:**
Generate reports that summarize each employeeâ€™s total working hours per month.

**Approach:**
- Utilize the `MonthlyReport` model.
- Create a management command or admin action to generate reports.
- Alternatively, implement views for Authorized Users to generate and view reports on-demand.

**Implementation Steps:**

1. **Define the `MonthlyReport` Model:**

   Ensure the `MonthlyReport` model is correctly defined.

   ```python
   # backend/employees/models.py

   class MonthlyReport(models.Model):
       employee = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='monthly_reports')
       month = models.IntegerField()  # 1-12
       year = models.IntegerField()
       total_working_hours = models.DurationField()

       class Meta:
           unique_together = ('employee', 'month', 'year')

       def __str__(self):
           return f"{self.employee.username} - {self.month}/{self.year}"
   ```

2. **Create a Management Command to Generate Reports:**

   Using Django's management commands allows you to generate reports via the command line or scheduled tasks.

   ```bash
   mkdir -p backend/employees/management/commands
   touch backend/employees/management/__init__.py
   touch backend/employees/management/commands/__init__.py
   touch backend/employees/management/commands/generate_monthly_reports.py
   ```

   ```python
   # backend/employees/management/commands/generate_monthly_reports.py

   from django.core.management.base import BaseCommand
   from employees.models import AttendanceRecord, MonthlyReport, User
   from django.utils import timezone
   from datetime import datetime, timedelta

   class Command(BaseCommand):
       help = 'Generate monthly attendance reports for all employees.'

       def handle(self, *args, **kwargs):
           today = timezone.now().date()
           # Get the previous month
           first_day_of_current_month = today.replace(day=1)
           last_month = first_day_of_current_month - timedelta(days=1)
           month = last_month.month
           year = last_month.year

           for user in User.objects.filter(is_authorized=False):
               attendance_records = AttendanceRecord.objects.filter(
                   employee=user,
                   date__month=month,
                   date__year=year
               )
               total_seconds = 0
               for record in attendance_records:
                   if record.first_check_in and record.last_check_out:
                       check_in = datetime.combine(record.date, record.first_check_in)
                       check_out = datetime.combine(record.date, record.last_check_out)
                       duration = check_out - check_in
                       total_seconds += duration.total_seconds()
               total_working_hours = timedelta(seconds=total_seconds)
               # Create or update the MonthlyReport
               report, created = MonthlyReport.objects.update_or_create(
                   employee=user,
                   month=month,
                   year=year,
                   defaults={'total_working_hours': total_working_hours}
               )
               self.stdout.write(self.style.SUCCESS(
                   f"Report {'created' if created else 'updated'} for {user.username} for {month}/{year}"
               ))
   ```

   **Explanation:**
   - Calculates total working hours for the previous month for each employee.
   - Creates or updates the `MonthlyReport` accordingly.

3. **Run the Management Command:**

   ```bash
   python manage.py generate_monthly_reports
   ```

   **Output:**
   - Messages indicating the creation or update of reports for each employee.

4. **Create Views and Templates for Authorized Users to View Reports:**

   To allow Authorized Users to view these reports via the web interface, implement the following:

   - **Views:**

     ```python
     # backend/employees/views.py

     @login_required(login_url='authorized_login')
     @user_passes_test(is_authorized_user)
     def view_monthly_reports(request):
         reports = MonthlyReport.objects.select_related('employee').all().order_by('-year', '-month')
         
         # Search or filter functionality can be added here
         query = request.GET.get('q')
         if query:
             reports = reports.filter(
                 Q(employee__username__icontains=query) |
                 Q(employee__profile__full_name__icontains=query)
             )
         
         # Pagination
         paginator = Paginator(reports, 20)  # Show 20 reports per page
         page_number = request.GET.get('page')
         page_obj = paginator.get_page(page_number)
         
         context = {
             'page_obj': page_obj,
             'query': query,
         }
         return render(request, 'employees/view_monthly_reports.html', context)
     ```

   - **URL Configuration:**

     ```python
     # backend/employees/urls.py

     urlpatterns += [
         # ... existing URLs ...
         path('reports/monthly/', views.view_monthly_reports, name='view_monthly_reports'),
     ]
     ```

   - **Template:**

     ```html
     <!-- backend/employees/templates/employees/view_monthly_reports.html -->

     <!DOCTYPE html>
     <html lang="en">
     <head>
         <meta charset="UTF-8">
         <title>Monthly Attendance Reports</title>
         <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
     </head>
     <body>
         <div class="container mt-5">
             <h2>Monthly Attendance Reports</h2>
             <a href="{% url 'authorized_dashboard' %}" class="btn btn-secondary mb-3">Back to Dashboard</a>
             
             <form method="GET" action="{% url 'view_monthly_reports' %}" class="mb-3">
                 <div class="input-group">
                     <input type="text" name="q" class="form-control" placeholder="Search by username or name" value="{{ query }}">
                     <button type="submit" class="btn btn-primary">Search</button>
                 </div>
             </form>

             <table class="table table-bordered">
                 <thead>
                     <tr>
                         <th>Employee Username</th>
                         <th>Employee Name</th>
                         <th>Month</th>
                         <th>Year</th>
                         <th>Total Working Hours</th>
                     </tr>
                 </thead>
                 <tbody>
                     {% for report in page_obj.object_list %}
                         <tr>
                             <td>{{ report.employee.username }}</td>
                             <td>{{ report.employee.profile.full_name }}</td>
                             <td>{{ report.month }}</td>
                             <td>{{ report.year }}</td>
                             <td>{{ report.total_working_hours }}</td>
                         </tr>
                     {% empty %}
                         <tr>
                             <td colspan="5">No reports found.</td>
                         </tr>
                     {% endfor %}
                 </tbody>
             </table>

             <!-- Pagination Controls -->
             <div class="pagination">
                 <span class="step-links">
                     {% if page_obj.has_previous %}
                         <a href="?page=1{% if query %}&q={{ query }}{% endif %}">&laquo; first</a>
                         <a href="?page={{ page_obj.previous_page_number }}{% if query %}&q={{ query }}{% endif %}">previous</a>
                     {% endif %}

                     <span class="current">
                         Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}.
                     </span>

                     {% if page_obj.has_next %}
                         <a href="?page={{ page_obj.next_page_number }}{% if query %}&q={{ query }}{% endif %}">next</a>
                         <a href="?page={{ page_obj.paginator.num_pages }}{% if query %}&q={{ query }}{% endif %}">last &raquo;</a>
                     {% endif %}
                 </span>
             </div>
         </div>
     </body>
     </html>
     ```

5. **Automate Report Generation (Optional):**

   To ensure monthly reports are generated automatically, consider scheduling the management command using **Celery Beat** or a cron job. However, implementing Celery is covered in the bonus section.

---

## **3.4. Implement Additional (Bonus) Features**

### **3.4.1. Set Up Celery for Asynchronous Tasks**

**Objective:**
Use Celery to handle asynchronous tasks such as sending notifications.

**Approach:**
- Integrate Celery with Django.
- Use Redis as the message broker.
- Create Celery tasks for sending notifications.

**Implementation Steps:**

1. **Install Celery and Redis:**

   ```bash
   pip install celery
   brew install redis
   ```

2. **Start Redis Server:**

   ```bash
   brew services start redis
   ```

3. **Configure Celery in Django:**

   - **Create `celery.py` in the `backend` Directory:**

     ```python
     # backend/celery.py

     import os
     from celery import Celery

     os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')

     app = Celery('backend')
     app.config_from_object('django.conf:settings', namespace='CELERY')
     app.autodiscover_tasks()
     ```

   - **Update `__init__.py` to Load Celery:**

     ```python
     # backend/__init__.py

     from .celery import app as celery_app

     __all__ = ['celery_app']
     ```

   - **Update `settings.py` with Celery Configuration:**

     ```python
     # backend/settings.py

     CELERY_BROKER_URL = 'redis://localhost:6379/0'
     CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'
     CELERY_ACCEPT_CONTENT = ['json']
     CELERY_TASK_SERIALIZER = 'json'
     CELERY_RESULT_SERIALIZER = 'json'
     CELERY_TIMEZONE = 'UTC'
     ```

4. **Create Celery Tasks:**

   - **Create `tasks.py` in the `employees` App:**

     ```bash
     touch backend/employees/tasks.py
     ```

     ```python
     # backend/employees/tasks.py

     from celery import shared_task
     from .models import Notification
     from django.contrib.auth import get_user_model

     User = get_user_model()

     @shared_task
     def send_notifications():
         # For example, send all unread notifications via email or another channel
         notifications = Notification.objects.filter(is_read=False)
         for notification in notifications:
             # Implement actual sending logic here
             # e.g., send_email(notification.recipient.email, notification.message)
             
             # For demonstration, we'll just mark them as read
             notification.is_read = True
             notification.save()

             # Log or print
             print(f"Notification sent to {notification.recipient.username}: {notification.message}")
     ```

     **Note:**
     - Replace the comment with actual sending logic (e.g., using Django's email framework).

5. **Update Views to Use Celery Tasks:**

   Modify notification creation to enqueue tasks instead of handling synchronously.

   ```python
   # backend/employees/views.py

   from .tasks import send_notifications

   def notify_authorized_users_late(employee, date, lateness, deduction):
       authorized_users = User.objects.filter(is_authorized=True)
       message = f"Employee {employee.username} was late on {date} by {lateness.seconds // 60} minutes and {deduction} days were deducted from their leave."
       for user in authorized_users:
           Notification.objects.create(recipient=user, message=message)
       # Enqueue the task to send notifications
       send_notifications.delay()

   def notify_authorized_users_low_leave(user):
       if user.profile.annual_leave_balance < 3:
           authorized_users = User.objects.filter(is_authorized=True)
           message = f"Employee {user.username} now has {user.profile.annual_leave_balance} days of annual leave remaining."
           for auth_user in authorized_users:
               Notification.objects.create(recipient=auth_user, message=message)
           # Enqueue the task to send notifications
           send_notifications.delay()

   def notify_authorized_users_leave_request(leave_request):
       authorized_users = User.objects.filter(is_authorized=True)
       message = f"Employee {leave_request.employee.username} has requested leave from {leave_request.start_date} to {leave_request.end_date} ({leave_request.days} days). Reason: {leave_request.reason}"
       for user in authorized_users:
           Notification.objects.create(recipient=user, message=message)
       # Enqueue the task to send notifications
       send_notifications.delay()

   def notify_employee_leave_decision(leave_request):
       employee = leave_request.employee
       if leave_request.status == 'A':
           message = f"Your leave request from {leave_request.start_date} to {leave_request.end_date} has been approved."
       elif leave_request.status == 'R':
           message = f"Your leave request from {leave_request.start_date} to {leave_request.end_date} has been rejected."
       Notification.objects.create(recipient=employee, message=message)
       # Enqueue the task to send notifications
       send_notifications.delay()
   ```

6. **Run Celery Worker:**

   Open a new terminal window/tab and navigate to your project directory. Activate your virtual environment and run the Celery worker.

   ```bash
   celery -A backend worker -l info
   ```

   **Note:**
   - Ensure that Redis is running.
   - The worker must be running to process tasks.

7. **Optional: Set Up Celery Beat for Periodic Tasks:**

   If you have tasks that need to run periodically (e.g., daily summaries), set up Celery Beat.

   ```bash
   celery -A backend beat -l info
   ```

   **Note:** For now, our tasks are triggered on events, so Celery Beat isn't necessary unless adding periodic tasks.

---

### **3.4.2. Containerize the Application Using Docker**

**Objective:**
Package your Django application, PostgreSQL database, and Celery workers into Docker containers for consistent and scalable deployment.

**Approach:**
- Create a `Dockerfile` for the Django application.
- Create a `docker-compose.yml` to define services: web (Django), db (PostgreSQL), redis, and worker (Celery).

**Implementation Steps:**

1. **Create a `Dockerfile` in the Project Root:**

   ```dockerfile
   # backend/Dockerfile

   # Use official Python image as base
   FROM python:3.9-slim

   # Set environment variables
   ENV PYTHONDONTWRITEBYTECODE 1
   ENV PYTHONUNBUFFERED 1

   # Set working directory
   WORKDIR /code

   # Install dependencies
   COPY requirements.txt /code/
   RUN pip install --upgrade pip
   RUN pip install -r requirements.txt

   # Copy project
   COPY . /code/

   # Collect static files
   RUN python manage.py collectstatic --noinput

   # Expose port 8000
   EXPOSE 8000

   # Start server
   CMD ["gunicorn", "backend.wsgi:application", "--bind", "0.0.0.0:8000"]
   ```

   **Notes:**
   - **Gunicorn:** A production-ready WSGI HTTP server.
   - **Collectstatic:** Ensure static files are collected during build.

2. **Update `requirements.txt`:**

   Ensure `gunicorn`, `celery`, and other dependencies are listed.

   ```txt
   django>=4.2
   djangorestframework
   psycopg2-binary
   celery
   redis
   gunicorn
   drf-yasg  # For Swagger
   ```

   **Note:** Adjust versions as needed.

3. **Create `docker-compose.yml` in Project Root:**

   ```yaml
   # backend/docker-compose.yml

   version: '3.9'

   services:
     web:
       build: .
       command: gunicorn backend.wsgi:application --bind 0.0.0.0:8000
       volumes:
         - .:/code
       ports:
         - "8000:8000"
       env_file:
         - .env
       depends_on:
         - db
         - redis

     db:
       image: postgres:13
       volumes:
         - postgres_data:/var/lib/postgresql/data/
       environment:
         POSTGRES_DB: db_2n
         POSTGRES_USER: admin
         POSTGRES_PASSWORD: admin

     redis:
       image: redis:6
       ports:
         - "6379:6379"

     worker:
       build: .
       command: celery -A backend worker -l info
       volumes:
         - .:/code
       env_file:
         - .env
       depends_on:
         - db
         - redis

   volumes:
     postgres_data:
   ```

   **Notes:**
   - **Environment Variables:** Sensitive data should be managed via `.env` files.
   - **Worker:** Defines a Celery worker service.

4. **Create a `.env` File for Environment Variables:**

   ```env
   # backend/.env

   DEBUG=1
   SECRET_KEY=your-secret-key
   DJANGO_ALLOWED_HOSTS=localhost 127.0.0.1 [::1]
   DATABASE_URL=postgres://admin:admin@db:5432/db_2n
   CELERY_BROKER_URL=redis://redis:6379/0
   CELERY_RESULT_BACKEND=redis://redis:6379/0
   ```

   **Update `settings.py` to Use Environment Variables:**

   Install `python-decouple` or handle environment variables manually.

   **For simplicity, use `python-decouple`:**

   ```bash
   pip install python-decouple
   ```

   Update `requirements.txt` accordingly.

   ```python
   # backend/settings.py

   from decouple import config
   import dj_database_url

   # SECRET KEY
   SECRET_KEY = config('SECRET_KEY')

   # DEBUG
   DEBUG = config('DEBUG', default=False, cast=bool)

   # Allowed Hosts
   ALLOWED_HOSTS = config('DJANGO_ALLOWED_HOSTS').split()

   # Database
   DATABASES = {
       'default': dj_database_url.config(default=config('DATABASE_URL'))
   }

   # Celery Configuration
   CELERY_BROKER_URL = config('CELERY_BROKER_URL')
   CELERY_RESULT_BACKEND = config('CELERY_RESULT_BACKEND')
   ```

   **Install Dependencies:**

   ```bash
   pip install dj-database-url python-decouple
   ```

   **Update `requirements.txt`:**

   ```txt
   django>=4.2
   djangorestframework
   psycopg2-binary
   celery
   redis
   gunicorn
   drf-yasg
   dj-database-url
   python-decouple
   ```

5. **Modify `management/commands/generate_monthly_reports.py` to Handle Dockerized Database:**

   Ensure database connections in Celery tasks and management commands point to the correct Docker service.

   However, using `DATABASE_URL` should handle this.

6. **Build and Run Docker Containers:**

   ```bash
   docker-compose up --build
   ```

   **Expected Outcome:**
   - Django application accessible at `http://localhost:8000/`.
   - PostgreSQL running and accessible within Docker network.
   - Redis running as the Celery broker.
   - Celery worker processing tasks.

7. **Run Celery Worker Separately (If Not Defined in `docker-compose.yml`):**

   The `worker` service is already defined in `docker-compose.yml`, so it should start alongside `web`. Ensure the `celery` command in `worker` section matches your setup.

8. **Optional: Use Docker Compose Commands to Manage Services:**

   - **Stop Services:**

     ```bash
     docker-compose down
     ```

   - **Rebuild Services:**

     ```bash
     docker-compose up --build
     ```

9. **Ensure Static Files are Served Correctly:**

   Using WhiteNoise or configuring static file serving is essential for production. For development, the current setup should suffice.

   **For Production:**
   - Install and configure `whitenoise`.
   - Update `MIDDLEWARE` in `settings.py`:

     ```python
     # backend/settings.py

     MIDDLEWARE = [
         'whitenoise.middleware.WhiteNoiseMiddleware',
         # ... existing middleware ...
     ]
     ```

   - Update `STATICFILES_STORAGE`:

     ```python
     # backend/settings.py

     STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'
     ```

   - Collect static files:

     ```bash
     python manage.py collectstatic
     ```

10. **Secure the Application:**

    - Generate a strong `SECRET_KEY`.
    - Set `DEBUG=0` for production.
    - Define proper `ALLOWED_HOSTS`.
    - Use environment variables to manage sensitive data.

---

### **3.4.3. Integrate Swagger for API Documentation**

**Objective:**
Provide interactive API documentation using Swagger to visualize and test API endpoints.

**Approach:**
- Use `drf-yasg` to auto-generate Swagger documentation.
- Configure URLs and views to serve the Swagger UI.

**Implementation Steps:**

1. **Install `drf-yasg`:**

   ```bash
   pip install drf-yasg
   ```

   **Update `requirements.txt`:**

   ```txt
   django>=4.2
   djangorestframework
   psycopg2-binary
   celery
   redis
   gunicorn
   drf-yasg
   dj-database-url
   python-decouple
   ```

2. **Update `settings.py` to Include `drf_yasg` in Installed Apps:**

   ```python
   # backend/settings.py

   INSTALLED_APPS = [
       # ... existing apps ...
       'rest_framework',
       'drf_yasg',
       'backend.employees.apps.EmployeesConfig',
   ]
   ```

3. **Configure Swagger URLs:**

   Update `backend/urls.py` to include Swagger endpoints.

   ```python
   # backend/urls.py

   from django.contrib import admin
   from django.urls import path, include
   from rest_framework import permissions
   from drf_yasg.views import get_schema_view
   from drf_yasg import openapi

   schema_view = get_schema_view(
       openapi.Info(
           title="Employee Attendance API",
           default_version='v1',
           description="API documentation for Employee Attendance Tracking System",
           terms_of_service="https://www.example.com/terms/",
           contact=openapi.Contact(email="contact@example.com"),
           license=openapi.License(name="BSD License"),
       ),
       public=True,
       permission_classes=(permissions.AllowAny,),
   )

   urlpatterns = [
       path('admin/', admin.site.urls),
       path('auth/', include('backend.employees.urls')),
       
       # Swagger URLs
       path('swagger/', schema_view.with_ui('swagger', cache_timeout=0), name='schema-swagger-ui'),
       path('redoc/', schema_view.with_ui('redoc', cache_timeout=0), name='schema-redoc'),
   ]
   ```

4. **Define API Endpoints (Optional):**

   If you have API endpoints (e.g., using Django Rest Framework), ensure they are properly defined to be documented by Swagger.

   **Example:**

   ```python
   # backend/employees/api/serializers.py

   from rest_framework import serializers
   from .models import AttendanceRecord, LeaveRequest, User

   class UserSerializer(serializers.ModelSerializer):
       class Meta:
           model = User
           fields = ('id', 'username', 'email', 'is_authorized')

   class AttendanceRecordSerializer(serializers.ModelSerializer):
       employee = UserSerializer(read_only=True)

       class Meta:
           model = AttendanceRecord
           fields = '__all__'

   class LeaveRequestSerializer(serializers.ModelSerializer):
       employee = UserSerializer(read_only=True)

       class Meta:
           model = LeaveRequest
           fields = '__all__'
   ```

   ```python
   # backend/employees/api/views.py

   from rest_framework import viewsets
   from .serializers import AttendanceRecordSerializer, LeaveRequestSerializer, UserSerializer
   from .models import AttendanceRecord, LeaveRequest, User

   class UserViewSet(viewsets.ModelViewSet):
       queryset = User.objects.all()
       serializer_class = UserSerializer

   class AttendanceRecordViewSet(viewsets.ModelViewSet):
       queryset = AttendanceRecord.objects.all()
       serializer_class = AttendanceRecordSerializer

   class LeaveRequestViewSet(viewsets.ModelViewSet):
       queryset = LeaveRequest.objects.all()
       serializer_class = LeaveRequestSerializer
   ```

   ```python
   # backend/employees/api/urls.py

   from django.urls import path, include
   from rest_framework.routers import DefaultRouter
   from .views import UserViewSet, AttendanceRecordViewSet, LeaveRequestViewSet

   router = DefaultRouter()
   router.register(r'users', UserViewSet)
   router.register(r'attendance', AttendanceRecordViewSet)
   router.register(r'leaves', LeaveRequestViewSet)

   urlpatterns = [
       path('', include(router.urls)),
   ]
   ```

   **Include API URLs in Project URLs:**

   ```python
   # backend/urls.py

   urlpatterns += [
       path('api/', include('backend.employees.api.urls')),
   ]
   ```

5. **Access Swagger Documentation:**

   - Navigate to `http://localhost:8000/swagger/` to view the Swagger UI.
   - Navigate to `http://localhost:8000/redoc/` for ReDoc documentation.

6. **Test API Endpoints via Swagger UI:**

   - Use the Swagger interface to test GET, POST, PUT, DELETE operations on your API endpoints.

---

## **3.5. Commit Changes to GitHub**

After implementing the enhancements, ensure all changes are tracked and committed to your Git repository.

```bash
git add .
git commit -m "Enhance attendance features: automatic leave deductions and notifications; develop leave management and reporting; integrate Celery, Docker, and Swagger"
git push origin main
```

---

## **3.6. Final Testing and Verification**

**Objective:**
Ensure all implemented features work seamlessly.

**Testing Steps:**

1. **Authentication:**
   - **Personnel:**
     - Log in.
     - View leave balance.
     - Check-In and check-Out.
     - Request leave.
   - **Authorized Users:**
     - Log in.
     - View and approve/reject leave requests.
     - View attendance records and monthly reports.
     - Receive notifications for lateness and low leave balances.

2. **Attendance Tracking:**
   - Verify automatic leave deductions based on lateness.
   - Check that Authorized Users receive appropriate notifications.

3. **Leave Management:**
   - Ensure employees can request leaves within their leave balance.
   - Verify that approving/rejecting leave requests updates leave balances correctly.
   - Confirm that notifications are sent upon approval/rejection.

4. **Reporting:**
   - Generate monthly reports and verify total working hours.
   - Ensure reports are accurate based on attendance records.

5. **Celery and Notifications:**
   - Confirm that notifications are handled asynchronously.
   - Ensure Celery worker is processing tasks without errors.

6. **Docker Deployment:**
   - Test the application running inside Docker containers.
   - Verify inter-service communication (web, db, redis, worker).

7. **Swagger Documentation:**
   - Access Swagger UI and verify all API endpoints are documented correctly.
   - Test API endpoints via Swagger.

---

## **3.7. Additional Best Practices and Recommendations**

1. **Security Enhancements:**
   - **HTTPS:** Ensure the application uses HTTPS in production.
   - **Secret Management:** Use secure methods to manage secret keys and environment variables.
   - **User Permissions:** Regularly review user permissions to prevent unauthorized access.

2. **Code Quality:**
   - Use linters like `flake8` and formatters like `black` to maintain code consistency.
   - Write unit and integration tests to ensure code reliability.

3. **Logging and Monitoring:**
   - Implement logging to track application behavior and errors.
   - Use monitoring tools to keep an eye on application performance.

4. **Scaling Considerations:**
   - Optimize database queries to improve performance.
   - Use caching mechanisms (e.g., Redis) to reduce database load.

5. **Documentation:**
   - Maintain clear and comprehensive documentation for developers and users.
   - Update Swagger documentation regularly to reflect API changes.

6. **Regular Backups:**
   - Schedule regular backups for the database to prevent data loss.

7. **Continuous Integration/Continuous Deployment (CI/CD):**
   - Set up CI/CD pipelines to automate testing and deployment.

---

## **Conclusion**

By following the steps outlined above, you have successfully enhanced your Employee Attendance Tracking application with advanced features such as automatic leave deductions, notifications, leave management, reporting, and integrated bonus features like Celery, Docker, and Swagger. Ensure thorough testing to maintain application reliability and consider implementing additional best practices to secure and optimize your system further.

### **Next Steps:**

1. **Continuous Improvement:**
   - Solicit feedback from potential users and iterate on the application based on their needs.

2. **Feature Expansion:**
   - Consider adding more functionalities like role-based permissions, detailed analytics, or integration with other HR systems.

3. **Deployment:**
   - Deploy the Dockerized application to a cloud platform (e.g., AWS, DigitalOcean, Heroku) for real-world usage.

4. **Maintenance:**
   - Regularly update dependencies and monitor the application for issues.

---

Feel free to reach out if you encounter any challenges or need further assistance with any of the implementation steps. Good luck with your project!